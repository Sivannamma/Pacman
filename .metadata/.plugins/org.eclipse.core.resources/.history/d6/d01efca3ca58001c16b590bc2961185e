import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.ImageIcon;
import javax.swing.JPanel;

/*
 * This class is used for creating the actual board of the Pacman
 * We are reading the Pacman matrix from file and then initializing the board accordingly.
 * 
 * The matrix values : 
 * 0 -> blocks inside the Pacman area.
 * 1 -> the outline's of the game (the board lines)
 * 2 -> where the player can walk (also where we can place points to collect)
 */
public class PacmanBoard extends JPanel implements ActionListener, MovementConnecter, rePainting {

	private static final long serialVersionUID = 1L;

	// offset for the borders
	private final int bourderOffset = 25;
	// variable for the block size (how big each cell is)
	public static int BLOCK_SIZE;
	// variable for the matrix size
	public static int MATRIX_SIZE;
	// variable for the screen size
	private static int SCREEN_SIZE;
	// to place every line in an offset from the corner of the screen
	private int pointsOffset = 5;

	private Image pacman;
	private Image ghost;
	private Ghost ghostClass;
	private int corX, corY;

	PacmanGraph graph;

	// points matrix
	private Point[][] points;
//	private final short board[] = {
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
//
//	};

	 private final short board[] = {
			 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	 2, 2, 2, 2,
	
	 };

	// constructor :
	PacmanBoard(int blockSize, int matrixSize) {
		// initializing :
		this.BLOCK_SIZE = blockSize;
		this.MATRIX_SIZE = matrixSize;

		// (valued as size of the matrix multiply by cell size)
		this.SCREEN_SIZE = this.BLOCK_SIZE * this.MATRIX_SIZE;

		// initializing the points matrix to our matrix size.
		points = new Point[this.MATRIX_SIZE][this.MATRIX_SIZE];

		// starting position : +2 in order to not be on the edge
		corX = pointsOffset + 2;
		corY = pointsOffset + 2;
		initPoints();
		initBoard();
	}

	private void initBoard() {
		loadPacman();
		loadGhosts();
		PacmanControll pac = new PacmanControll(corX, corY, 24, this, points);
		Thread thread = new Thread(pac);
		thread.start();
		addKeyListener(pac);
		setBackground(Color.black);
		setFocusable(true);
		setPreferredSize(new Dimension(750, 800));
	}

	private void loadPacman() {
		ImageIcon iid = new ImageIcon("Images/pacman.png");
		pacman = iid.getImage();
		pacman = pacman.getScaledInstance(BLOCK_SIZE, BLOCK_SIZE, Image.SCALE_DEFAULT);
	}
	
	private void loadGhosts() {
		ImageIcon iid = new ImageIcon("Images/ghost.png");
		ghost = iid.getImage();
		ghost = ghost.getScaledInstance(BLOCK_SIZE, BLOCK_SIZE, Image.SCALE_DEFAULT);
		
		System.out.println(graph);
		ghostClass = new Ghost(103, 199, new ChasingBFS(), graph);
		Thread thread = new Thread(ghostClass);
		thread.start();
	}

	private void drawBoard(Graphics2D g2d) {
		// variable for the index of the matrix board
		short i = 0;
		// variables for looping over the matrix we want to draw on the panel
		int x, y;

		// looping my size in order to draw the board :
		for (y = 0; y < SCREEN_SIZE; y += BLOCK_SIZE) {
			for (x = 0; x < SCREEN_SIZE; x += BLOCK_SIZE) {

				g2d.setColor(new Color(0, 72, 251));
				g2d.setStroke(new BasicStroke(5));

				// drawing lines vertical lines :
				if (x == 0) {
					g2d.drawLine(x + pointsOffset, y + pointsOffset, x + pointsOffset,
							y + BLOCK_SIZE - 1 + pointsOffset);
				}
				// drawing lines vertical lines :
				if (x == SCREEN_SIZE - BLOCK_SIZE) {
					g2d.drawLine(x + bourderOffset + pointsOffset, y + pointsOffset, x + bourderOffset + pointsOffset,
							y + BLOCK_SIZE - 1 + pointsOffset);
				}
				// drawing lines horizontal lines :
				if (y == 0) {
					g2d.drawLine(x + pointsOffset, y + pointsOffset, x + BLOCK_SIZE - 1 + pointsOffset,
							y + pointsOffset);
				}
				// drawing lines horizontal lines :
				if (y == SCREEN_SIZE - BLOCK_SIZE) {
					g2d.drawLine(x + pointsOffset, y + bourderOffset + pointsOffset, x + BLOCK_SIZE - 1 + pointsOffset,
							y + bourderOffset + pointsOffset);
				}
				// we need to fill block ( where the player cannot walk)
				if (board[i] == 0) {
					g2d.fillRect(x + pointsOffset, y + pointsOffset, BLOCK_SIZE, BLOCK_SIZE);
				}

				// we want to fill the dots where the player can eat and walk
				if (board[i] == 2) {
					// color white :
					g2d.setColor(new Color(255, 255, 255));
					g2d.fillOval(x + (BLOCK_SIZE / 2), y + (BLOCK_SIZE / 2), 6, 6); // BLOCK_SIZE/2 because we want to
					// place in the middle
				}

				i++;
			}
		}
	}

	private void initPoints() {

		for (int row = 0; row < points.length; row++) {
			for (int column = 0; column < points.length; column++) {
				// if equals to 0 then its not walkable because it is a block.
				boolean isWalkable = board[row * MATRIX_SIZE + column] == 0 ? false : true;
				points[row][column] = new Point(row, column, isWalkable);
			}
		}
		graph = new PacmanGraph(points);
	}

	@Override
	public void paintComponent(Graphics g) {
		super.paintComponent(g);

		Graphics2D graphicComponent = (Graphics2D) g;
		drawBoard(graphicComponent);
		g.drawImage(pacman, corX, corY, this);

		int locX = (this.corX - 7) / this.BLOCK_SIZE;
		int locY = (this.corY - 7) / this.BLOCK_SIZE;
		board[locY * MATRIX_SIZE + locX] = 5; // symbolize as eaten
		
		g.drawImage(ghost, ghostClass.getCorX(), ghostClass.getCorY(), this);
	}

	@Override
	public void actionPerformed(ActionEvent e) {
		System.out.println("repainting");
		repaint();
	}

	// function of the interface that is connecting between pacmanControll and
	// pacmanBoard

	@Override
	public void setCoordinates(int x, int y) {

		this.corX = x;
		this.corY = y;
		repaint();

	}
	
}
